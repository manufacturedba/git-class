section
    div Methods for Constructing Promises
section
    strong Q.fcall
    section
        div. 
            Q.fcall is the simplest way to turn any function into a thenable.
    section(data-transition="slide-in fade-out")
        div.
            Turn this
        pre
            code.
                function addNumbers(a, b) {
                    return a + b;
                }
                
                console.log(addNumbers(2, 2));
                console.log('Blocked');
                
                Blocked
                4
    section(data-transition="fade-in")
        div Into this
        pre
            code.
                function addNumbers(a, b) {
                    return Q.fcall(function(){
                        return a + b;
                    });
                }
                
                addNumbers(2, 2).then(console.log);
                console.log('Not blocked');
                
                Not blocked
                4
section
    strong Q.Promise or Deferred
    section
        div.
            Q.Promise allows us to resolve, reject, or report progress
    section(data-transition="slide-in fade-out")
        pre
            code.
                function process(items) {
                    
                    return Q.Promise(function (resolve, reject, notify) {
                        
                        for (var i = 0, j = items; i < j.length; i++) {
                            if (j[i].type === 'error') {
                                reject('Encountered error');
                            } else {
                                j[i].processed = true;
                                notify((i + 1)/j.length);
                            }
                        }
                        
                        resolve(statuses);
                    });
                }
    section(data-transition="fade-in slide-out")
        pre
            code.
                process(tickets)
                    .then(function (result) {
                        log.info('Done processing tickets');
                    })
                    .fail(function (err) {
                        log.error(err);
                    })
                    .progress(function (progress) {
                        log.debug(Math.round(progress * 100) + "%");
                    });
    section
        div.
            Deferred constructed promises are much more suited to handling 
            non-promise returning asynchronous functions
    section
        pre
            code.
                function handleRequest (path) {
                    
                    var deferred = Q.defer();
                    
                    http.get(path, function (response) {
                        
                        response.on('data', deferred.resolve);
                        
                        response.on('error', deferred.reject);
                        
                    });
                    
                    return deferred.promise;
                }
        aside(class="notes").
            Hello
section
    strong Q.all and spread
    section 
        div. 
            In some instances, we would like to fulfill multiple promises at once. 
        aside(class="notes").    
            We can give Q.all an array of values (or promises) that when fulfilled
            will give an array of the fulfillment values of the passed promises.
            Q.all will also maintain the order in which promises are passed to it.
    section
        pre
            code.
                var requests = [];
                requests.push(handleRequest('/tickets'));
                requests.push(handleRequest('/orders'));
                requests.push(handleRequest('/receipts'));
                
                Q.all(requests)
                    .then(function (responses) {
                        
                        responses.forEach(function (response) {
                            log.debug(response.statusCode);
                        });
                        
                    })
                    .fail(log.error);
    section
        div.
            .spread allows us to use functions that take multiple arguments as our
            fulfillment handler in place of .then.
    section
        pre
            code.
                function updateOrder(order, email, label) {
                    
                    order.label = label;
                    
                    log.info('Sent email for ' + order.name);
                    log.debug(order.status);
                    
                    return order;
                }
                
                Q.all([createOrder(info), email(address), createLabel(info)])
                    .spread(updateOrder);
section
    strong Q.nfcall or Q.denodeify
    section
        div.
            Q.nfcall allows us to wrap around asynchronous functions with a 
            "node-style" callback.
        aside(class="notes").
            Meaning callbacks that are error-first
    section(data-transition="slide-in fade-out")
        div This
        pre(class="fragment")
            code.
                fs.readFile('file.html', 'utf-8', function (err, contents) {
                    if (err) {
                        throw(err);
                    }
                    
                    doSomething(contents);
                });
    section(data-transition="fade-in slide-out")
        div Becomes this
        pre(class="fragment")
            code.
                Q.nfcall(fs.readFile, 'file.html', 'utf-8')
                    .then(function (contents) {
                        doSomething(contents);
                    })
                    .fail(function (error) {
                        log.error(error);
                    });
    section
        div.
            With Q.denodeify we can create a new promise returning function
    section
        pre
            code.
                var readFile = Q.denodeify(fs.readFile);
                
                readFile('file_one.html', 'utf-8').then(function (contents) {
                    log.debug('Read file one contents');
                });
                
                readFile('file_two.html', 'utf-8').then(function (contents) {
                    log.debug('Read file two contents');
                });
section 
    strong Promise Chaining
    section
        div.
            Promise chains are a powerful promise producing strategy when building
            large functions
    section
        pre
            code.
                function doSomethingElseSync(stuff) {
                    stuff.status = 'handled';
                    return stuff;
                }
                
                doSomething()
                    .then(function (response) {
                        return doSomethingElseSync(response);
                    })
                    .then(doSomethingElseAgain);
    section
        div.
            Other times we need multiple values from resolved promises for a function
        aside(class="notes").
            Thus we must nest together promises within a chain.
    section
        pre
            code.
                refillPetFood()
                .then(function (filled) {
                    
                    turnOffLights()
                    .then(function (finished) {
                        
                        if ((filled && finished) === true) {
                            leaveHouse();
                        }
                        
                    });
                    
                })
